#![feature(prelude_import)]
//! Event store module
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
#[macro_use]
extern crate diesel;
mod db_event {
    //! Database storage for [`Event`]s
    use crate::schema::events;
    use crate::{event::Event, EventData};
    use chrono::{DateTime, Utc};
    use std::convert::TryFrom;
    use uuid::Uuid;
    /// Internal event definition
    ///
    /// This is similar to an [`Event`], however has a few database-specific changes made to it:
    ///
    /// * The `sequence_number` field is added to align the struct shape to the table structure. This is
    ///   an autogenerated value added by Postgres and **should not be set in user code**.
    /// * The `data` field is now a generic [`serde_json::Value`] instead of a specialised,
    ///   application-specific struct. This maps to the Postgres `json` field type.
    #[table_name = "events"]
    pub struct DBEvent {
        /// Event ID
        pub id: Uuid,
        /// Sequence number
        ///
        /// This field is autogenerated by the database and should not be set in user code
        pub sequence_number: Option<i32>,
        /// Event type
        ///
        /// This field provides information about how this event was originated.
        pub event_type: String,
        /// Entity Type
        ///
        /// This field must contain the name of the table the event relates to
        pub entity_type: String,
        /// The ID of the entity (user, organisation, etc) that this event aggregates into
        pub entity_id: Uuid,
        /// Event data
        ///
        /// This is a generic [`serde_json::Value`] representation of the event payload. It is
        /// deserialised into a more useful form using `Event::try_from()`. If the event has been
        /// purged, this will be `None` for security/compliance reasons - the data must be deleted from
        /// both the event log and the aggregate tables. Check the `purged_at` or `purger_id` fields to
        /// check the purge status.
        pub data: Option<serde_json::Value>,
        /// The ID of the creator of this event
        pub session_id: Option<Uuid>,
        /// The time at which this event was created
        pub created_at: DateTime<Utc>,
        /// Purger subject ID
        ///
        /// Will be `None` if event is not purged
        pub purger_id: Option<Uuid>,
        /// The time at which this event was purged, if any
        pub purged_at: Option<DateTime<Utc>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DBEvent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                DBEvent {
                    id: ref __self_0_0,
                    sequence_number: ref __self_0_1,
                    event_type: ref __self_0_2,
                    entity_type: ref __self_0_3,
                    entity_id: ref __self_0_4,
                    data: ref __self_0_5,
                    session_id: ref __self_0_6,
                    created_at: ref __self_0_7,
                    purger_id: ref __self_0_8,
                    purged_at: ref __self_0_9,
                } => {
                    let mut debug_trait_builder = f.debug_struct("DBEvent");
                    let _ = debug_trait_builder.field("id", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("sequence_number", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("event_type", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("entity_type", &&(*__self_0_3));
                    let _ = debug_trait_builder.field("entity_id", &&(*__self_0_4));
                    let _ = debug_trait_builder.field("data", &&(*__self_0_5));
                    let _ = debug_trait_builder.field("session_id", &&(*__self_0_6));
                    let _ = debug_trait_builder.field("created_at", &&(*__self_0_7));
                    let _ = debug_trait_builder.field("purger_id", &&(*__self_0_8));
                    let _ = debug_trait_builder.field("purged_at", &&(*__self_0_9));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for DBEvent {
        #[inline]
        fn clone(&self) -> DBEvent {
            match *self {
                DBEvent {
                    id: ref __self_0_0,
                    sequence_number: ref __self_0_1,
                    event_type: ref __self_0_2,
                    entity_type: ref __self_0_3,
                    entity_id: ref __self_0_4,
                    data: ref __self_0_5,
                    session_id: ref __self_0_6,
                    created_at: ref __self_0_7,
                    purger_id: ref __self_0_8,
                    purged_at: ref __self_0_9,
                } => DBEvent {
                    id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    sequence_number: ::core::clone::Clone::clone(&(*__self_0_1)),
                    event_type: ::core::clone::Clone::clone(&(*__self_0_2)),
                    entity_type: ::core::clone::Clone::clone(&(*__self_0_3)),
                    entity_id: ::core::clone::Clone::clone(&(*__self_0_4)),
                    data: ::core::clone::Clone::clone(&(*__self_0_5)),
                    session_id: ::core::clone::Clone::clone(&(*__self_0_6)),
                    created_at: ::core::clone::Clone::clone(&(*__self_0_7)),
                    purger_id: ::core::clone::Clone::clone(&(*__self_0_8)),
                    purged_at: ::core::clone::Clone::clone(&(*__self_0_9)),
                },
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_insertable_for_dbevent() {
        extern crate std;
        use diesel;
        use diesel::insertable::Insertable;
        use diesel::prelude::*;
        use diesel::query_builder::UndecoratedInsertRecord;
        impl<'insert> Insertable<events::table> for DBEvent {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<events::id, Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::sequence_number, i32>>,
                std::option::Option<diesel::dsl::Eq<events::event_type, String>>,
                std::option::Option<diesel::dsl::Eq<events::entity_type, String>>,
                std::option::Option<diesel::dsl::Eq<events::entity_id, Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::data, serde_json::Value>>,
                std::option::Option<diesel::dsl::Eq<events::session_id, Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::created_at, DateTime<Utc>>>,
                std::option::Option<diesel::dsl::Eq<events::purger_id, Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::purged_at, DateTime<Utc>>>,
            ) as Insertable<events::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(events::id.eq(self.id)),
                    self.sequence_number.map(|x| events::sequence_number.eq(x)),
                    std::option::Option::Some(events::event_type.eq(self.event_type)),
                    std::option::Option::Some(events::entity_type.eq(self.entity_type)),
                    std::option::Option::Some(events::entity_id.eq(self.entity_id)),
                    self.data.map(|x| events::data.eq(x)),
                    self.session_id.map(|x| events::session_id.eq(x)),
                    std::option::Option::Some(events::created_at.eq(self.created_at)),
                    self.purger_id.map(|x| events::purger_id.eq(x)),
                    self.purged_at.map(|x| events::purged_at.eq(x)),
                )
                    .values()
            }
        }
        impl<'insert> Insertable<events::table> for &'insert DBEvent {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<events::id, &'insert Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::sequence_number, &'insert i32>>,
                std::option::Option<diesel::dsl::Eq<events::event_type, &'insert String>>,
                std::option::Option<diesel::dsl::Eq<events::entity_type, &'insert String>>,
                std::option::Option<diesel::dsl::Eq<events::entity_id, &'insert Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::data, &'insert serde_json::Value>>,
                std::option::Option<diesel::dsl::Eq<events::session_id, &'insert Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::created_at, &'insert DateTime<Utc>>>,
                std::option::Option<diesel::dsl::Eq<events::purger_id, &'insert Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::purged_at, &'insert DateTime<Utc>>>,
            ) as Insertable<events::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(events::id.eq(&self.id)),
                    self.sequence_number
                        .as_ref()
                        .map(|x| events::sequence_number.eq(x)),
                    std::option::Option::Some(events::event_type.eq(&self.event_type)),
                    std::option::Option::Some(events::entity_type.eq(&self.entity_type)),
                    std::option::Option::Some(events::entity_id.eq(&self.entity_id)),
                    self.data.as_ref().map(|x| events::data.eq(x)),
                    self.session_id.as_ref().map(|x| events::session_id.eq(x)),
                    std::option::Option::Some(events::created_at.eq(&self.created_at)),
                    self.purger_id.as_ref().map(|x| events::purger_id.eq(x)),
                    self.purged_at.as_ref().map(|x| events::purged_at.eq(x)),
                )
                    .values()
            }
        }
        impl<'insert> UndecoratedInsertRecord<events::table> for DBEvent {}
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_dbevent() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for DBEvent
        where
            (
                Uuid,
                Option<i32>,
                String,
                String,
                Uuid,
                Option<serde_json::Value>,
                Option<Uuid>,
                DateTime<Utc>,
                Option<Uuid>,
                Option<DateTime<Utc>>,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                Uuid,
                Option<i32>,
                String,
                String,
                Uuid,
                Option<serde_json::Value>,
                Option<Uuid>,
                DateTime<Utc>,
                Option<Uuid>,
                Option<DateTime<Utc>>,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    Uuid,
                    Option<i32>,
                    String,
                    String,
                    Uuid,
                    Option<serde_json::Value>,
                    Option<Uuid>,
                    DateTime<Utc>,
                    Option<Uuid>,
                    Option<DateTime<Utc>>,
                ) = Queryable::build(row);
                Self {
                    id: (row.0.into()),
                    sequence_number: (row.1.into()),
                    event_type: (row.2.into()),
                    entity_type: (row.3.into()),
                    entity_id: (row.4.into()),
                    data: (row.5.into()),
                    session_id: (row.6.into()),
                    created_at: (row.7.into()),
                    purger_id: (row.8.into()),
                    purged_at: (row.9.into()),
                }
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_as_changeset_for_dbevent() {
        extern crate std;
        use diesel;
        use diesel::prelude::*;
        use diesel::query_builder::AsChangeset;
        impl<'update> AsChangeset for &'update DBEvent {
            type Target = events::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<events::sequence_number, &'update i32>>,
                diesel::dsl::Eq<events::event_type, &'update String>,
                diesel::dsl::Eq<events::entity_type, &'update String>,
                diesel::dsl::Eq<events::entity_id, &'update Uuid>,
                std::option::Option<diesel::dsl::Eq<events::data, &'update serde_json::Value>>,
                std::option::Option<diesel::dsl::Eq<events::session_id, &'update Uuid>>,
                diesel::dsl::Eq<events::created_at, &'update DateTime<Utc>>,
                std::option::Option<diesel::dsl::Eq<events::purger_id, &'update Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::purged_at, &'update DateTime<Utc>>>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.sequence_number
                        .as_ref()
                        .map(|x| events::sequence_number.eq(x)),
                    events::event_type.eq(&self.event_type),
                    events::entity_type.eq(&self.entity_type),
                    events::entity_id.eq(&self.entity_id),
                    self.data.as_ref().map(|x| events::data.eq(x)),
                    self.session_id.as_ref().map(|x| events::session_id.eq(x)),
                    events::created_at.eq(&self.created_at),
                    self.purger_id.as_ref().map(|x| events::purger_id.eq(x)),
                    self.purged_at.as_ref().map(|x| events::purged_at.eq(x)),
                )
                    .as_changeset()
            }
        }
        impl<'update> AsChangeset for DBEvent {
            type Target = events::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<events::sequence_number, i32>>,
                diesel::dsl::Eq<events::event_type, String>,
                diesel::dsl::Eq<events::entity_type, String>,
                diesel::dsl::Eq<events::entity_id, Uuid>,
                std::option::Option<diesel::dsl::Eq<events::data, serde_json::Value>>,
                std::option::Option<diesel::dsl::Eq<events::session_id, Uuid>>,
                diesel::dsl::Eq<events::created_at, DateTime<Utc>>,
                std::option::Option<diesel::dsl::Eq<events::purger_id, Uuid>>,
                std::option::Option<diesel::dsl::Eq<events::purged_at, DateTime<Utc>>>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.sequence_number.map(|x| events::sequence_number.eq(x)),
                    events::event_type.eq(self.event_type),
                    events::entity_type.eq(self.entity_type),
                    events::entity_id.eq(self.entity_id),
                    self.data.map(|x| events::data.eq(x)),
                    self.session_id.map(|x| events::session_id.eq(x)),
                    events::created_at.eq(self.created_at),
                    self.purger_id.map(|x| events::purger_id.eq(x)),
                    self.purged_at.map(|x| events::purged_at.eq(x)),
                )
                    .as_changeset()
            }
        }
    }
    impl<S: EventData> TryFrom<Event<S>> for DBEvent {
        type Error = serde_json::Error;
        /// Attempt to convert an [`Event`] into a `DBEvent`
        ///
        /// This serialises the `data` field into a [`serde_json::Value`]. All other fields are left as
        /// is.
        fn try_from(other: Event<S>) -> Result<DBEvent, Self::Error> {
            let data: Option<serde_json::Value> = if let Some(d) = other.data {
                Some(serde_json::to_value(d)?)
            } else {
                None
            };
            Ok(DBEvent {
                id: other.id,
                sequence_number: None,
                event_type: other.event_type,
                entity_type: other.entity_type,
                entity_id: other.entity_id,
                session_id: other.session_id,
                purger_id: other.purger_id,
                created_at: other.created_at,
                purged_at: other.purged_at,
                data,
            })
        }
    }
}
mod event {
    //! An event
    use super::{db_event::DBEvent, EventData};
    use chrono::{DateTime, Utc};
    use std::convert::TryFrom;
    use uuid::Uuid;
    /// Event definition
    ///
    /// This is a wrapper around types in the [`events`](crate::events) module with added metadata
    pub struct Event<D>
    where
        D: EventData,
    {
        /// Event ID
        pub id: Uuid,
        /// Event type
        ///
        /// The type of this event in PascalCase, like `OrganisationCreated` or `StudyCurated`
        pub event_type: String,
        /// Entity Type
        ///
        /// This field must contain the name of the table the event relates to, like `organisations` or
        /// `model_enquiries`.
        pub entity_type: String,
        /// The ID of the entity (user, organisation, etc) that this event aggregates into
        pub entity_id: Uuid,
        /// The ID of the creator of this event
        pub session_id: Option<Uuid>,
        /// Purger subject ID
        ///
        /// Will be `None` if event is not purged
        pub purger_id: Option<Uuid>,
        /// Event data
        ///
        /// If the event has been purged, this will be `None` for security/compliance reasons - the data
        /// must be deleted from both the event log and the aggregate tables. Check the `purged_at` or
        /// `purger_id` fields to check the purge status.
        pub data: Option<D>,
        /// The time at which this event was created
        pub created_at: DateTime<Utc>,
        /// The time at which this event was purged, if any
        pub purged_at: Option<DateTime<Utc>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<D: ::core::fmt::Debug> ::core::fmt::Debug for Event<D>
    where
        D: EventData,
    {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Event {
                    id: ref __self_0_0,
                    event_type: ref __self_0_1,
                    entity_type: ref __self_0_2,
                    entity_id: ref __self_0_3,
                    session_id: ref __self_0_4,
                    purger_id: ref __self_0_5,
                    data: ref __self_0_6,
                    created_at: ref __self_0_7,
                    purged_at: ref __self_0_8,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Event");
                    let _ = debug_trait_builder.field("id", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("event_type", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("entity_type", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("entity_id", &&(*__self_0_3));
                    let _ = debug_trait_builder.field("session_id", &&(*__self_0_4));
                    let _ = debug_trait_builder.field("purger_id", &&(*__self_0_5));
                    let _ = debug_trait_builder.field("data", &&(*__self_0_6));
                    let _ = debug_trait_builder.field("created_at", &&(*__self_0_7));
                    let _ = debug_trait_builder.field("purged_at", &&(*__self_0_8));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<D: ::core::clone::Clone> ::core::clone::Clone for Event<D>
    where
        D: EventData,
    {
        #[inline]
        fn clone(&self) -> Event<D> {
            match *self {
                Event {
                    id: ref __self_0_0,
                    event_type: ref __self_0_1,
                    entity_type: ref __self_0_2,
                    entity_id: ref __self_0_3,
                    session_id: ref __self_0_4,
                    purger_id: ref __self_0_5,
                    data: ref __self_0_6,
                    created_at: ref __self_0_7,
                    purged_at: ref __self_0_8,
                } => Event {
                    id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    event_type: ::core::clone::Clone::clone(&(*__self_0_1)),
                    entity_type: ::core::clone::Clone::clone(&(*__self_0_2)),
                    entity_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                    session_id: ::core::clone::Clone::clone(&(*__self_0_4)),
                    purger_id: ::core::clone::Clone::clone(&(*__self_0_5)),
                    data: ::core::clone::Clone::clone(&(*__self_0_6)),
                    created_at: ::core::clone::Clone::clone(&(*__self_0_7)),
                    purged_at: ::core::clone::Clone::clone(&(*__self_0_8)),
                },
            }
        }
    }
    impl<D> ::core::marker::StructuralPartialEq for Event<D> where D: EventData {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<D: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Event<D>
    where
        D: EventData,
    {
        #[inline]
        fn eq(&self, other: &Event<D>) -> bool {
            match *other {
                Event {
                    id: ref __self_1_0,
                    event_type: ref __self_1_1,
                    entity_type: ref __self_1_2,
                    entity_id: ref __self_1_3,
                    session_id: ref __self_1_4,
                    purger_id: ref __self_1_5,
                    data: ref __self_1_6,
                    created_at: ref __self_1_7,
                    purged_at: ref __self_1_8,
                } => match *self {
                    Event {
                        id: ref __self_0_0,
                        event_type: ref __self_0_1,
                        entity_type: ref __self_0_2,
                        entity_id: ref __self_0_3,
                        session_id: ref __self_0_4,
                        purger_id: ref __self_0_5,
                        data: ref __self_0_6,
                        created_at: ref __self_0_7,
                        purged_at: ref __self_0_8,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Event<D>) -> bool {
            match *other {
                Event {
                    id: ref __self_1_0,
                    event_type: ref __self_1_1,
                    entity_type: ref __self_1_2,
                    entity_id: ref __self_1_3,
                    session_id: ref __self_1_4,
                    purger_id: ref __self_1_5,
                    data: ref __self_1_6,
                    created_at: ref __self_1_7,
                    purged_at: ref __self_1_8,
                } => match *self {
                    Event {
                        id: ref __self_0_0,
                        event_type: ref __self_0_1,
                        entity_type: ref __self_0_2,
                        entity_id: ref __self_0_3,
                        session_id: ref __self_0_4,
                        purger_id: ref __self_0_5,
                        data: ref __self_0_6,
                        created_at: ref __self_0_7,
                        purged_at: ref __self_0_8,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                    }
                },
            }
        }
    }
    impl<D> Default for Event<D>
    where
        D: EventData,
    {
        fn default() -> Self {
            Self {
                id: Uuid::new_v4(),
                event_type: D::event_type(),
                entity_type: D::entity_type(),
                entity_id: Uuid::new_v4(),
                session_id: None,
                purger_id: None,
                data: None,
                created_at: Utc::now(),
                purged_at: None,
            }
        }
    }
    impl<S: EventData> TryFrom<DBEvent> for Event<S> {
        type Error = serde_json::Error;
        /// Attempt to decode a [`DBEvent`] into an `Event`
        ///
        /// [`DBEvent`]s carry their paylaod as a [`serde_json::Value`]. This method will attempt to
        /// [deserialise that structure into the specialised event payload `S`.
        ///
        /// # Examples
        ///
        /// ## Read a `UserRegistered` event
        ///
        /// ```rust
        /// use backend::{event_store::{DBEvent, Event}, events::UserRegistered};
        /// use std::convert::TryFrom;
        ///
        ///    # let created_at = chrono::Utc::now();
        ///    # let id = uuid::Uuid::new_v4();
        ///    # let entity_id = uuid::Uuid::new_v4();
        ///
        ///    let db_event = DBEvent {
        ///        data: Some(serde_json::json!({
        ///            "first_name": "Bobby",
        ///            "last_name": "Beans",
        ///            "email": "bobby@bea.ns",
        ///            "password": "HASHEDLOL",
        ///            "company_name": "",
        ///        })),
        ///        event_type: "UserRegistered".to_string(),
        ///        entity_type: "user".to_string(),
        ///        # id,
        ///        # entity_id,
        ///        # session_id: None,
        ///        # purger_id: None,
        ///        # created_at,
        ///        # purged_at: None,
        ///        # sequence_number: None,
        ///
        ///        // ...
        ///    };
        ///
        ///    let user_created: Event<UserRegistered> = Event::try_from(db_event).unwrap();
        ///
        ///    assert_eq!(user_created, Event {
        ///        data: Some(UserRegistered {
        ///            first_name: "Bobby".to_string(),
        ///            last_name: "Beans".to_string(),
        ///            email: "bobby@bea.ns".to_string(),
        ///            password: "HASHEDLOL".to_string(),
        ///            company_name: "".to_string(),
        ///        }),
        ///        event_type: "UserRegistered".to_string(),
        ///        entity_type: "user".to_string(),
        ///        # id,
        ///        # entity_id,
        ///        # session_id: None,
        ///        # purger_id: None,
        ///        # created_at,
        ///        # purged_at: None,
        ///    });
        /// ```
        ///
        /// [`DBEvent`]: crate::event_store::DBEvent
        fn try_from(other: DBEvent) -> Result<Event<S>, Self::Error> {
            let data: Option<S> = if let Some(d) = other.data {
                serde_json::from_value(d)?
            } else {
                None
            };
            Ok(Event {
                id: other.id,
                event_type: other.event_type,
                entity_type: other.entity_type,
                entity_id: other.entity_id,
                session_id: other.session_id,
                purger_id: other.purger_id,
                created_at: other.created_at,
                purged_at: other.purged_at,
                data,
            })
        }
    }
}
mod schema {
    #![allow(missing_docs)]
    pub mod events {
        #![allow(dead_code)]
        pub use self::columns::*;
        use diesel::associations::HasTable;
        use diesel::insertable::Insertable;
        use diesel::query_builder::nodes::Identifier;
        use diesel::query_builder::*;
        use diesel::query_source::joins::{Join, JoinOn};
        use diesel::query_source::{AppearsInFromClause, Never, Once};
        use diesel::sql_types::*;
        use diesel::{JoinTo, QuerySource, Table};
        /// Re-exports all of the columns of this table, as well as the
        /// table struct renamed to the module name. This is meant to be
        /// glob imported for functions which only deal with one table.
        pub mod dsl {
            pub use super::columns::created_at;
            pub use super::columns::data;
            pub use super::columns::entity_id;
            pub use super::columns::entity_type;
            pub use super::columns::event_type;
            pub use super::columns::id;
            pub use super::columns::purged_at;
            pub use super::columns::purger_id;
            pub use super::columns::sequence_number;
            pub use super::columns::session_id;
            pub use super::table as events;
        }
        #[allow(non_upper_case_globals, dead_code)]
        /// A tuple of all of the columns on this table
        pub const all_columns: (
            id,
            sequence_number,
            event_type,
            entity_type,
            entity_id,
            data,
            session_id,
            created_at,
            purger_id,
            purged_at,
        ) = (
            id,
            sequence_number,
            event_type,
            entity_type,
            entity_id,
            data,
            session_id,
            created_at,
            purger_id,
            purged_at,
        );
        #[allow(non_camel_case_types)]
        /// The actual table struct
        ///
        /// This is the type which provides the base methods of the query
        /// builder, such as `.select` and `.filter`.
        pub struct table;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::fmt::Debug for table {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    table => {
                        let mut debug_trait_builder = f.debug_tuple("table");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for table {
            #[inline]
            fn clone(&self) -> table {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::marker::Copy for table {}
        #[allow(non_snake_case, unused_extern_crates, unused_imports)]
        fn _impl_query_id_for_table() {
            extern crate std;
            use diesel;
            use diesel::query_builder::QueryId;
            #[allow(non_camel_case_types)]
            impl QueryId for table {
                type QueryId = table;
                const HAS_STATIC_QUERY_ID: bool = true;
            }
        }
        impl table {
            #[allow(dead_code)]
            /// Represents `table_name.*`, which is sometimes necessary
            /// for efficient count queries. It cannot be used in place of
            /// `all_columns`
            pub fn star(&self) -> star {
                star
            }
        }
        /// The SQL type of all of the columns on this table
        pub type SqlType = (
            Uuid,
            Nullable<Int4>,
            Varchar,
            Varchar,
            Uuid,
            Nullable<Jsonb>,
            Nullable<Uuid>,
            Timestamptz,
            Nullable<Uuid>,
            Nullable<Timestamptz>,
        );
        /// Helper type for representing a boxed query from this table
        pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
        impl QuerySource for table {
            type FromClause = Identifier<'static>;
            type DefaultSelection = <Self as Table>::AllColumns;
            fn from_clause(&self) -> Self::FromClause {
                Identifier("events")
            }
            fn default_selection(&self) -> Self::DefaultSelection {
                Self::all_columns()
            }
        }
        impl AsQuery for table {
            type SqlType = SqlType;
            type Query = SelectStatement<Self>;
            fn as_query(self) -> Self::Query {
                SelectStatement::simple(self)
            }
        }
        impl Table for table {
            type PrimaryKey = (id);
            type AllColumns = (
                id,
                sequence_number,
                event_type,
                entity_type,
                entity_id,
                data,
                session_id,
                created_at,
                purger_id,
                purged_at,
            );
            fn primary_key(&self) -> Self::PrimaryKey {
                (id)
            }
            fn all_columns() -> Self::AllColumns {
                (
                    id,
                    sequence_number,
                    event_type,
                    entity_type,
                    entity_id,
                    data,
                    session_id,
                    created_at,
                    purger_id,
                    purged_at,
                )
            }
        }
        impl HasTable for table {
            type Table = Self;
            fn table() -> Self::Table {
                table
            }
        }
        impl IntoUpdateTarget for table {
            type WhereClause = <<Self as AsQuery>::Query as IntoUpdateTarget>::WhereClause;
            fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                self.as_query().into_update_target()
            }
        }
        impl AppearsInFromClause<table> for table {
            type Count = Once;
        }
        impl AppearsInFromClause<table> for () {
            type Count = Never;
        }
        impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
        where
            Join<Left, Right, Kind>: JoinTo<table>,
        {
            type FromClause = Join<Left, Right, Kind>;
            type OnClause = <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
            fn join_target(rhs: Join<Left, Right, Kind>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = Join::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<Join, On> JoinTo<JoinOn<Join, On>> for table
        where
            JoinOn<Join, On>: JoinTo<table>,
        {
            type FromClause = JoinOn<Join, On>;
            type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
            fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = JoinOn::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
        where
            SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>,
        {
            type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
            type OnClause = <SelectStatement<F, S, D, W, O, L, Of, G> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: SelectStatement<F, S, D, W, O, L, Of, G>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = SelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
        where
            BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>,
        {
            type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
            type OnClause = <BoxedSelectStatement<'a, QS, ST, DB> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: BoxedSelectStatement<'a, QS, ST, DB>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = BoxedSelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<T> Insertable<T> for table
        where
            <table as AsQuery>::Query: Insertable<T>,
        {
            type Values = <<table as AsQuery>::Query as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                self.as_query().values()
            }
        }
        impl<'a, T> Insertable<T> for &'a table
        where
            table: Insertable<T>,
        {
            type Values = <table as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                (*self).values()
            }
        }
        /// Contains all of the columns of this table
        pub mod columns {
            use super::table;
            use diesel::backend::Backend;
            use diesel::query_builder::{AstPass, QueryFragment, SelectStatement};
            use diesel::query_source::joins::{Inner, Join, JoinOn, LeftOuter};
            use diesel::query_source::{AppearsInFromClause, Never, Once};
            use diesel::result::QueryResult;
            use diesel::sql_types::*;
            use diesel::{AppearsOnTable, Expression, QuerySource, SelectableExpression};
            #[allow(non_camel_case_types, dead_code)]
            /// Represents `table_name.*`, which is sometimes needed for
            /// efficient count queries. It cannot be used in place of
            /// `all_columns`, and has a `SqlType` of `()` to prevent it
            /// being used that way
            pub struct star;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for star {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        star => {
                            let mut debug_trait_builder = f.debug_tuple("star");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for star {
                #[inline]
                fn clone(&self) -> star {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for star {}
            impl Expression for star {
                type SqlType = ();
            }
            impl<DB: Backend> QueryFragment<DB> for star
            where
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".*");
                    Ok(())
                }
            }
            impl SelectableExpression<table> for star {}
            impl AppearsOnTable<table> for star {}
            #[allow(non_camel_case_types, dead_code)]
            pub struct id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        id => {
                            let mut debug_trait_builder = f.debug_tuple("id");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for id {
                #[inline]
                fn clone(&self) -> id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for id {
                    type QueryId = id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for id {
                #[inline]
                fn default() -> id {
                    id {}
                }
            }
            impl ::diesel::expression::Expression for id {
                type SqlType = Uuid;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("id")
                }
            }
            impl SelectableExpression<table> for id {}
            impl<QS> AppearsOnTable<QS> for id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
            where
                id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
            where
                id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id where
                id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for id where
                id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for id {}
            impl ::diesel::query_source::Column for id {
                type Table = table;
                const NAME: &'static str = "id";
            }
            impl<T> ::diesel::EqAll<T> for id
            where
                T: ::diesel::expression::AsExpression<Uuid>,
                ::diesel::dsl::Eq<id, T>: ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct sequence_number;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for sequence_number {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        sequence_number => {
                            let mut debug_trait_builder = f.debug_tuple("sequence_number");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for sequence_number {
                #[inline]
                fn clone(&self) -> sequence_number {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for sequence_number {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_sequence_number() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for sequence_number {
                    type QueryId = sequence_number;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for sequence_number {
                #[inline]
                fn default() -> sequence_number {
                    sequence_number {}
                }
            }
            impl ::diesel::expression::Expression for sequence_number {
                type SqlType = Nullable<Int4>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for sequence_number
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("sequence_number")
                }
            }
            impl SelectableExpression<table> for sequence_number {}
            impl<QS> AppearsOnTable<QS> for sequence_number where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for sequence_number
            where
                sequence_number: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for sequence_number
            where
                sequence_number: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for sequence_number where
                sequence_number: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for sequence_number where
                sequence_number: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for sequence_number {}
            impl ::diesel::query_source::Column for sequence_number {
                type Table = table;
                const NAME: &'static str = "sequence_number";
            }
            impl<T> ::diesel::EqAll<T> for sequence_number
            where
                T: ::diesel::expression::AsExpression<Nullable<Int4>>,
                ::diesel::dsl::Eq<sequence_number, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for sequence_number where Rhs : :: diesel :: expression :: AsExpression < < < sequence_number as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new ( self , rhs . as_expression ( ) ) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for sequence_number where Rhs : :: diesel :: expression :: AsExpression < < < sequence_number as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new ( self , rhs . as_expression ( ) ) } }
            impl < Rhs > :: std :: ops :: Div < Rhs > for sequence_number where Rhs : :: diesel :: expression :: AsExpression < < < sequence_number as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Div > :: Rhs > { type Output = :: diesel :: expression :: ops :: Div < Self , Rhs :: Expression > ; fn div ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Div :: new ( self , rhs . as_expression ( ) ) } }
            impl < Rhs > :: std :: ops :: Mul < Rhs > for sequence_number where Rhs : :: diesel :: expression :: AsExpression < < < sequence_number as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Mul > :: Rhs > { type Output = :: diesel :: expression :: ops :: Mul < Self , Rhs :: Expression > ; fn mul ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Mul :: new ( self , rhs . as_expression ( ) ) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct event_type;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for event_type {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        event_type => {
                            let mut debug_trait_builder = f.debug_tuple("event_type");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for event_type {
                #[inline]
                fn clone(&self) -> event_type {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for event_type {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_event_type() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for event_type {
                    type QueryId = event_type;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for event_type {
                #[inline]
                fn default() -> event_type {
                    event_type {}
                }
            }
            impl ::diesel::expression::Expression for event_type {
                type SqlType = Varchar;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for event_type
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("event_type")
                }
            }
            impl SelectableExpression<table> for event_type {}
            impl<QS> AppearsOnTable<QS> for event_type where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for event_type
            where
                event_type: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for event_type
            where
                event_type: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for event_type where
                event_type: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for event_type where
                event_type: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for event_type {}
            impl ::diesel::query_source::Column for event_type {
                type Table = table;
                const NAME: &'static str = "event_type";
            }
            impl<T> ::diesel::EqAll<T> for event_type
            where
                T: ::diesel::expression::AsExpression<Varchar>,
                ::diesel::dsl::Eq<event_type, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct entity_type;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for entity_type {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        entity_type => {
                            let mut debug_trait_builder = f.debug_tuple("entity_type");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for entity_type {
                #[inline]
                fn clone(&self) -> entity_type {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for entity_type {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_entity_type() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for entity_type {
                    type QueryId = entity_type;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for entity_type {
                #[inline]
                fn default() -> entity_type {
                    entity_type {}
                }
            }
            impl ::diesel::expression::Expression for entity_type {
                type SqlType = Varchar;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for entity_type
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("entity_type")
                }
            }
            impl SelectableExpression<table> for entity_type {}
            impl<QS> AppearsOnTable<QS> for entity_type where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for entity_type
            where
                entity_type: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for entity_type
            where
                entity_type: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for entity_type where
                entity_type: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for entity_type where
                entity_type: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for entity_type {}
            impl ::diesel::query_source::Column for entity_type {
                type Table = table;
                const NAME: &'static str = "entity_type";
            }
            impl<T> ::diesel::EqAll<T> for entity_type
            where
                T: ::diesel::expression::AsExpression<Varchar>,
                ::diesel::dsl::Eq<entity_type, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct entity_id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for entity_id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        entity_id => {
                            let mut debug_trait_builder = f.debug_tuple("entity_id");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for entity_id {
                #[inline]
                fn clone(&self) -> entity_id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for entity_id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_entity_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for entity_id {
                    type QueryId = entity_id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for entity_id {
                #[inline]
                fn default() -> entity_id {
                    entity_id {}
                }
            }
            impl ::diesel::expression::Expression for entity_id {
                type SqlType = Uuid;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for entity_id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("entity_id")
                }
            }
            impl SelectableExpression<table> for entity_id {}
            impl<QS> AppearsOnTable<QS> for entity_id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for entity_id
            where
                entity_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for entity_id
            where
                entity_id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for entity_id where
                entity_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for entity_id where
                entity_id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for entity_id {}
            impl ::diesel::query_source::Column for entity_id {
                type Table = table;
                const NAME: &'static str = "entity_id";
            }
            impl<T> ::diesel::EqAll<T> for entity_id
            where
                T: ::diesel::expression::AsExpression<Uuid>,
                ::diesel::dsl::Eq<entity_id, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct data;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for data {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        data => {
                            let mut debug_trait_builder = f.debug_tuple("data");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for data {
                #[inline]
                fn clone(&self) -> data {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for data {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_data() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for data {
                    type QueryId = data;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for data {
                #[inline]
                fn default() -> data {
                    data {}
                }
            }
            impl ::diesel::expression::Expression for data {
                type SqlType = Nullable<Jsonb>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for data
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("data")
                }
            }
            impl SelectableExpression<table> for data {}
            impl<QS> AppearsOnTable<QS> for data where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for data
            where
                data: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for data
            where
                data: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for data where
                data: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for data where
                data: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for data {}
            impl ::diesel::query_source::Column for data {
                type Table = table;
                const NAME: &'static str = "data";
            }
            impl<T> ::diesel::EqAll<T> for data
            where
                T: ::diesel::expression::AsExpression<Nullable<Jsonb>>,
                ::diesel::dsl::Eq<data, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct session_id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for session_id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        session_id => {
                            let mut debug_trait_builder = f.debug_tuple("session_id");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for session_id {
                #[inline]
                fn clone(&self) -> session_id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for session_id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_session_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for session_id {
                    type QueryId = session_id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for session_id {
                #[inline]
                fn default() -> session_id {
                    session_id {}
                }
            }
            impl ::diesel::expression::Expression for session_id {
                type SqlType = Nullable<Uuid>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for session_id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("session_id")
                }
            }
            impl SelectableExpression<table> for session_id {}
            impl<QS> AppearsOnTable<QS> for session_id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for session_id
            where
                session_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for session_id
            where
                session_id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for session_id where
                session_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for session_id where
                session_id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for session_id {}
            impl ::diesel::query_source::Column for session_id {
                type Table = table;
                const NAME: &'static str = "session_id";
            }
            impl<T> ::diesel::EqAll<T> for session_id
            where
                T: ::diesel::expression::AsExpression<Nullable<Uuid>>,
                ::diesel::dsl::Eq<session_id, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct created_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for created_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        created_at => {
                            let mut debug_trait_builder = f.debug_tuple("created_at");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for created_at {
                #[inline]
                fn clone(&self) -> created_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for created_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_created_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for created_at {
                    type QueryId = created_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for created_at {
                #[inline]
                fn default() -> created_at {
                    created_at {}
                }
            }
            impl ::diesel::expression::Expression for created_at {
                type SqlType = Timestamptz;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for created_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("created_at")
                }
            }
            impl SelectableExpression<table> for created_at {}
            impl<QS> AppearsOnTable<QS> for created_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for created_at where
                created_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for created_at where
                created_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for created_at {}
            impl ::diesel::query_source::Column for created_at {
                type Table = table;
                const NAME: &'static str = "created_at";
            }
            impl<T> ::diesel::EqAll<T> for created_at
            where
                T: ::diesel::expression::AsExpression<Timestamptz>,
                ::diesel::dsl::Eq<created_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new ( self , rhs . as_expression ( ) ) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new ( self , rhs . as_expression ( ) ) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct purger_id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for purger_id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        purger_id => {
                            let mut debug_trait_builder = f.debug_tuple("purger_id");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for purger_id {
                #[inline]
                fn clone(&self) -> purger_id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for purger_id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_purger_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for purger_id {
                    type QueryId = purger_id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for purger_id {
                #[inline]
                fn default() -> purger_id {
                    purger_id {}
                }
            }
            impl ::diesel::expression::Expression for purger_id {
                type SqlType = Nullable<Uuid>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for purger_id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("purger_id")
                }
            }
            impl SelectableExpression<table> for purger_id {}
            impl<QS> AppearsOnTable<QS> for purger_id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for purger_id
            where
                purger_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for purger_id
            where
                purger_id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for purger_id where
                purger_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for purger_id where
                purger_id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for purger_id {}
            impl ::diesel::query_source::Column for purger_id {
                type Table = table;
                const NAME: &'static str = "purger_id";
            }
            impl<T> ::diesel::EqAll<T> for purger_id
            where
                T: ::diesel::expression::AsExpression<Nullable<Uuid>>,
                ::diesel::dsl::Eq<purger_id, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct purged_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for purged_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        purged_at => {
                            let mut debug_trait_builder = f.debug_tuple("purged_at");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for purged_at {
                #[inline]
                fn clone(&self) -> purged_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for purged_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_purged_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for purged_at {
                    type QueryId = purged_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for purged_at {
                #[inline]
                fn default() -> purged_at {
                    purged_at {}
                }
            }
            impl ::diesel::expression::Expression for purged_at {
                type SqlType = Nullable<Timestamptz>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for purged_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("purged_at")
                }
            }
            impl SelectableExpression<table> for purged_at {}
            impl<QS> AppearsOnTable<QS> for purged_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for purged_at
            where
                purged_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for purged_at
            where
                purged_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for purged_at where
                purged_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for purged_at where
                purged_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for purged_at {}
            impl ::diesel::query_source::Column for purged_at {
                type Table = table;
                const NAME: &'static str = "purged_at";
            }
            impl<T> ::diesel::EqAll<T> for purged_at
            where
                T: ::diesel::expression::AsExpression<Nullable<Timestamptz>>,
                ::diesel::dsl::Eq<purged_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for purged_at where Rhs : :: diesel :: expression :: AsExpression < < < purged_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new ( self , rhs . as_expression ( ) ) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for purged_at where Rhs : :: diesel :: expression :: AsExpression < < < purged_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub ( self , rhs : Rhs ) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new ( self , rhs . as_expression ( ) ) } }
        }
    }
}
mod triggers {
    //! Traits attached to events to allow side effects when creating/updating entities
    use super::EventData;
    use std::fmt::Debug;
    /// Perform actions on an entity when it is created
    ///
    /// This trait can be implemented to allow side effects like emitting of events or calling HTTP APIs
    /// to be performed when an entity is created.
    pub trait OnCreated<ED>
    where
        ED: EventData,
    {
        /// The error type to return if the trigger failed
        type E: Debug;
        /// On create trigger
        ///
        /// Defaults to a noop
        fn on_created(&self) -> Result<(), Self::E> {
            Ok(())
        }
    }
    /// Perform actions on an entity when it is updated
    ///
    /// This trait can be implemented to allow side effects like emitting of events or calling HTTP APIs
    /// to be performed when an entity is updated.
    pub trait OnUpdated<ED>
    where
        ED: EventData,
    {
        /// The error type to return if the trigger failed
        type E: Debug;
        /// On update trigger
        ///
        /// Defaults to a noop
        fn on_updated(&self) -> Result<(), Self::E> {
            Ok(())
        }
    }
}
use crate::{
    db_event::DBEvent,
    event::Event,
    schema::events,
    triggers::{OnCreated, OnUpdated},
};
use diesel::{
    pg::PgConnection,
    prelude::*,
    query_builder::{AsChangeset, InsertStatement},
    query_dsl::methods::LoadQuery,
    r2d2::{ConnectionManager, Pool},
};
use log::error;
use serde::{de::Deserialize, Serialize};
use std::{convert::TryInto, error::Error};
use uuid::Uuid;
/// Trait implemented for all event payloads
///
/// **Note:** This is implemented automatically by the `EventData` derive. This should not be
/// implemented by hand.
pub trait EventData: Serialize + for<'de> Deserialize<'de> {
    /// Get the lowercase, plural entity type for this event like `users` or `password_resets`
    fn entity_type() -> String;
    /// Get the event type/identifier in PascalCase like `UserCreated` or `PasswordChanged`
    fn event_type() -> String;
}
/// Trait implemented for all entities
///
/// **Note:** This is implemented automatically by the `EventData` derive. This should not be
/// implemented by hand.
pub trait EntityId {
    /// Retrieve this entity's unique ID
    fn entity_id(&self) -> Uuid;
    /// Get the entity's type as a lowercase, plural string like `users` or `password_resets`
    fn entity_type() -> String;
}
/// Allow an entity creation event to be created from a given payload
pub trait FromCreatePayload<ED>
where
    ED: EventData,
{
    /// Create an entity creation [`Event`] from a given event payload and optional session ID
    fn from_create_payload(data: ED, session_id: Option<Uuid>) -> Event<ED> {
        Event {
            data: Some(data),
            session_id,
            ..Event::default()
        }
    }
}
/// Allow an entity update event to be created from a given payload
pub trait FromUpdatePayload<ED>
where
    ED: EventData,
{
    /// The target entity
    type Entity: EntityId;
    /// Create an update [`Event`] from a given event payload, base entity and optional session ID
    ///
    /// This event will be applied on top of the entity by the [`EventStore`].
    fn from_update_payload(data: ED, entity: &Self::Entity, session_id: Option<Uuid>) -> Event<ED> {
        Event {
            data: Some(data),
            entity_id: entity.entity_id(),
            session_id,
            ..Event::default()
        }
    }
}
/// Allow an entity delete event to be created from a given payload
///
/// The payload for these events will most often be empty. A deletion event can be created from the
/// [`Event`] struct fields. Other data can be added to the payload if required.
pub trait FromDeletePayload<ED>
where
    ED: EventData,
{
    /// The target entity
    type Entity: EntityId;
    /// Create a deletion [`Event`] from a given event payload and optional session ID
    ///
    /// This event will mark an entity as deleted. How this is applied is dependent on the entity's
    /// [`AggregateDelete`] implementation.
    fn from_delete_payload(data: ED, entity: &Self::Entity, session_id: Option<Uuid>) -> Event<ED> {
        Event {
            data: Some(data),
            entity_id: entity.entity_id(),
            session_id,
            ..Event::default()
        }
    }
}
/// Defines how an entity should be created from a given event
///
/// This trait can be implemented multiple times for multiple creation methods
pub trait AggregateCreate<ED>: Sized
where
    ED: EventData,
{
    /// Create a new entity from an event
    fn new(event: Event<ED>) -> Result<Self, Box<dyn Error>>;
}
/// Defines how an entity should be updated from a given event
pub trait AggregateApply<ED>: Sized
where
    ED: EventData,
{
    /// Apply an update event onto the entity, consuming the entity and returning a new instance
    fn apply(self, event: Event<ED>) -> Result<Self, Box<dyn Error>>;
}
/// Insert or update an entity in the chosen backing store
pub trait Aggregate: Sized + AsChangeset {
    /// Insert or update the current entity
    fn persist(&self, conn: &PgConnection) -> Result<Self, diesel::result::Error>;
}
/// Delete an entity from the backing store
pub trait AggregateDelete: Sized + AsChangeset {
    /// Remove the aggregated entity from its table
    ///
    /// This could be implemented as a deletion from the table, or the addition of a "deleted at"
    /// timestamp in the appropriate column.
    fn delete(self, conn: &PgConnection) -> Result<(), diesel::result::Error>;
}
/// Event store
///
/// Handles creation, updating and persistence of events in the backing store
///
/// # Examples
///
/// ## Derive events and entity for a `User`
///
/// Note that Diesel's `table_name` attribute is required on entity structs. No other database
/// backends are supported at this time.
///
/// ```rust,ignore
/// use uuid::Uuid;
///
/// /// Simple user entity
/// #[derive(event_store_derive::Entity)]
/// #[table_name = "users"]
/// struct User {
///     id: Uuid,
///     name: String,
///     email: String,
///     password: String,
/// }
///
/// /// A user creation event
/// #[derive(
///     serde_derive::Deserialize,
///     serde_derive::Serialize,
///     event_store_derive::CreateEvent,
/// )]
/// #[event_store(User)]
/// pub struct UserCreated {
///     pub user_id: Uuid,
///     pub name: String,
///     pub email: String,
///     pub password: String,
/// }
///
/// #[derive(
///     serde_derive::Deserialize,
///     serde_derive::Serialize,
///     event_store_derive::UpdateEvent,
/// )]
/// #[event_store(User)]
/// pub struct UserEmailChanged {
///     pub email: String
/// }
///
/// let session_id = Uuid::new_v4();
///
/// // Create the user
/// let user = User::from_create_payload(UserCreated {
///     user_id: Uuid::nil(),
///     name: "Bobby Beans".to_string(),
///     email: "bobby@bea.ns".to_string(),
///     password: "Haha this is supposed to be hashed".to_string(),
/// }, Some(session_id));
///
/// // Update the user's email address
/// let user = User::from_update_payload(UserEmailChanged {
///     email: "beans@bob.by".to_string(),
/// }, user, Some(session_id));
///
/// // Check that user was updated
/// assert_eq!(
///     user,
///     User {
///         user_id: Uuid::nil(),
///         name: "Bobby Beans".to_string(),
///         email: "beans@bob.by".to_string(),
///         password: "Haha this is supposed to be hashed".to_string(),
///     }
/// )
/// ```
pub struct EventStore {
    /// Postgres database connection
    connection: Pool<ConnectionManager<PgConnection>>,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for EventStore {
    #[inline]
    fn clone(&self) -> EventStore {
        match *self {
            EventStore {
                connection: ref __self_0_0,
            } => EventStore {
                connection: ::core::clone::Clone::clone(&(*__self_0_0)),
            },
        }
    }
}
impl EventStore {
    /// Create a new event store instance
    pub fn new(connection: Pool<ConnectionManager<PgConnection>>) -> EventStore {
        EventStore { connection }
    }
    /// Create a new entity `E` given an event with payload `ED`
    pub fn create<ED, E, S>(&self, event: Event<ED>) -> Result<E, Box<dyn Error>>
    where
        ED: EventData,
        S: Table,
        E: Aggregate + AggregateCreate<ED> + Insertable<S> + OnCreated<ED>,
        InsertStatement<S, E::Values>: LoadQuery<PgConnection, E>,
    {
        self.create_raw(&event.try_into()?)
    }
    /// Create a new entity from a raw [`DBEvent`]
    ///
    /// The [`EventStore::create`] method should be preferred. This method is used to ingest legacy
    /// events during a migration. The [`DBEvent`] is inserted into the event log verbatim without
    /// any payload shape checks.
    pub fn create_raw<ED, E, S>(&self, db_event: &DBEvent) -> Result<E, Box<dyn Error>>
    where
        ED: EventData,
        S: Table,
        E: Aggregate + AggregateCreate<ED> + Insertable<S> + OnCreated<ED>,
        InsertStatement<S, E::Values>: LoadQuery<PgConnection, E>,
    {
        let conn = self.connection.get()?;
        let created_entity = conn.transaction::<E, Box<dyn Error>, _>(|| {
            let db_event = diesel::insert_into(events::table)
                .values(db_event)
                .on_conflict(events::dsl::id)
                .do_update()
                .set(db_event)
                .get_result::<DBEvent>(&conn)?;
            let state = E::new(db_event.try_into()?)?;
            let result = state.persist(&conn)?;
            Ok(result)
        })?;
        match created_entity.on_created() {
            Ok(_) => (),
            Err(e) => {
                let lvl = ::log::Level::Error;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &[
                                "Failed to trigger creation side effect for event ",
                                " (ID ",
                                "): ",
                            ],
                            &match (&db_event.event_type, &db_event.id, &e) {
                                (arg0, arg1, arg2) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ),
                        lvl,
                        &(
                            "event_sauce",
                            "event_sauce",
                            "event-sauce/src/lib.rs",
                            277u32,
                        ),
                    );
                }
            }
        };
        Ok(created_entity)
    }
    /// Apply an event onto a given entity
    pub fn update<ED, E>(&self, state: E, event: Event<ED>) -> Result<E, Box<dyn Error>>
    where
        ED: EventData,
        E: Aggregate + AggregateApply<ED> + OnUpdated<ED>,
    {
        self.update_raw(state, &event.try_into()?)
    }
    /// Apply a raw [`DBEvent`] event onto a given entity
    ///
    /// The [`EventStore::update`] method should be preferred. This method is used to ingest legacy
    /// events during a migration. The [`DBEvent`] is inserted into the event log verbatim without
    /// any payload shape checks.
    pub fn update_raw<ED, E>(&self, state: E, db_event: &DBEvent) -> Result<E, Box<dyn Error>>
    where
        ED: EventData,
        E: Aggregate + AggregateApply<ED> + OnUpdated<ED>,
    {
        let conn = self.connection.get()?;
        let updated_entity = conn.transaction::<E, Box<dyn Error>, _>(|| {
            let db_event = diesel::insert_into(events::table)
                .values(db_event)
                .on_conflict(events::dsl::id)
                .do_update()
                .set(db_event)
                .get_result::<DBEvent>(&conn)?;
            let state: E = state.apply(db_event.try_into()?)?;
            let result = state.persist(&conn)?;
            Ok(result)
        })?;
        match updated_entity.on_updated() {
            Ok(_) => (),
            Err(e) => {
                let lvl = ::log::Level::Error;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &[
                                "Failed to trigger update side effect for event ",
                                " (ID ",
                                "): ",
                            ],
                            &match (&db_event.event_type, &db_event.id, &e) {
                                (arg0, arg1, arg2) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ),
                        lvl,
                        &(
                            "event_sauce",
                            "event_sauce",
                            "event-sauce/src/lib.rs",
                            325u32,
                        ),
                    );
                }
            }
        };
        Ok(updated_entity)
    }
    /// Delete an entity using a given event
    ///
    /// As mentioned in [`FromDeletePayload`], how this is applied is dependent on the entity's
    /// [`AggregateDelete`] implementation. It could remove the record from the database, or add a
    /// "deleted at" timestamp to an appropriate column.
    pub fn delete<ED, E>(&self, state: E, event: Event<ED>) -> Result<(), Box<dyn Error>>
    where
        ED: EventData,
        E: AggregateDelete,
    {
        self.delete_raw::<ED, E>(state, &event.try_into()?)
    }
    /// Delete an entity using a [`DBEvent`]
    ///
    /// The [`EventStore::delete`] method should be preferred. This method is used to ingest legacy
    /// events during a migration. The [`DBEvent`] is inserted into the event log verbatim without
    /// any payload shape checks.
    pub fn delete_raw<ED, E>(&self, state: E, db_event: &DBEvent) -> Result<(), Box<dyn Error>>
    where
        ED: EventData,
        E: AggregateDelete,
    {
        let conn = self.connection.get()?;
        conn.transaction::<(), Box<dyn Error>, _>(|| {
            let _db_event = diesel::insert_into(events::table)
                .values(db_event)
                .on_conflict(events::dsl::id)
                .do_update()
                .set(db_event)
                .get_result::<DBEvent>(&conn)?;
            state.delete(&conn)?;
            Ok(())
        })?;
        Ok(())
    }
}
